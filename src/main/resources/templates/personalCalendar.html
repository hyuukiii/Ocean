<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <title>개인 캘린더</title>
    <link th:href="@{/css/lnb.css}" rel='stylesheet' />
    <link th:href="@{/css/calendar.css}" rel='stylesheet' />
    <link rel="stylesheet" href="/static/css/calendar.css">

    <link href='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.css' rel='stylesheet' />
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js'></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=1a9ca55e1cb213f15176c2b99a62db20&libraries=services"></script>
</head>

<body>
<div class="app-container">
    <nav>
        <div th:replace="~{fragments/lnb :: lnbFragment}"></div>
    </nav>

    <div class="main-content">
        <div class="calendar-header">
            <div class="nav-arrows">
                <button id="prevMonthBtn" class="icon-arrow-left"></button>
                <span id="currentMonthText" class="current-month">6 JUN 2025</span>
                <button id="nextMonthBtn" class="icon-arrow-right"></button>
            </div>
        </div>
        <div id='calendar'></div>
    </div>

    <div class="sidebar-right"></div>

</div>

<div id="createEventModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h3>개인 일정 추가</h3>
            <button type="button" class="modal-close-button" onclick="closeCreateEventModal()">&times;</button>
        </div>
        <form id="eventForm" onsubmit="event.preventDefault(); saveEvent();">
            <div class="form-group flex-container">
                <input type="text" id="title" name="title" placeholder="제목을 입력하세요" required
                       oninvalid="this.setCustomValidity('제목은 필수 입력 사항입니다.')"
                       oninput="this.setCustomValidity('')">
                <input type="color" id="color" name="color" value="#0066CC">
            </div>

            <div class="form-group">
                <label class="icon-clock">일시</label>
                <div class="datetime-group">
                    <input type="datetime-local" id="startDatetime" name="startDatetime" required>
                    <span>&mdash;</span>
                    <input type="datetime-local" id="endDatetime" name="endDatetime" required>
                </div>
                <div class="checkbox-container">
                    <label for="allDay">종일</label>
                    <input type="checkbox" id="allDay" name="allDay">
                </div>
            </div>

            <div class="form-group">
                <label class="icon-user-detail">참가자 선택</label>
                <div class="checkbox-container" id="workspaceMembers"></div>
            </div>

            <div class="form-group">
                <label for="description" class="icon-description">설명 추가</label>
                <textarea id="description" name="description"  placeholder="자세한 설명을 입력하세요."></textarea>
            </div>


            <div class="form-group">
                <div class="file-input-container">
                    <span class="icon icon-attach"></span>
                    <span>첨부파일 추가</span>
                    <input type="file" id="fileUpload" name="files" multiple>
                </div>
                <ul id="insertedFiles" style="list-style: none; padding: 0; margin-top: 10px;"></ul>
            </div>

            <div class="form-group">
                <label for="notification" class="icon-bell">알림 시간</label>
                <select id="notification" name="notification" required>
                    <option value="0">알림 없음</option>
                    <option value="1440">전날 오전 9시</option>
                    <option value="540">당일 오전 9시</option>
                </select>
            </div>

            <div class="form-group">
                <label for="location" class="icon-location">위치 추가</label>
                <div class="search-wrapper">
                    <input type="text" id="location" name="location" placeholder="장소명으로 검색하세요">
                    <button type="button" id="searchBtn">검색</button>
                </div>
                <div id="map" style="width:100%;height:200px;margin-top:10px;"></div>
                <ul id="placesList"></ul>

                <input type="hidden" id="placeName" name="placeName">
                <input type="hidden" id="placeAddress" name="placeAddress">
                <input type="hidden" id="placeId" name="placeId">
                <input type="hidden" id="placeLat" name="placeLat">
                <input type="hidden" id="placeLng" name="placeLng">
            </div>


            <div class="form-group">
                <label for="priority" class="icon-priority">중요도</label>
                <select id="priority" name="priority" required>
                    <option value="LOW">낮음</option>
                    <option value="NORMAL" selected>보통</option>
                    <option value="HIGH">높음</option>
                </select>
            </div>

            <div class="form-group">
                <label for="isShared">공유 여부</label>
                <select id="isShared" name="isShared">
                    <option value="0">비공유</option>
                    <option value="1">공유</option>
                </select>
            </div>


            <div class="submit-button-wrapper">
                <button type="submit">등록하기</button>
            </div>
        </form>
    </div>
</div>

<div id="eventDetailModal" class="modal-overlay">
    <div class="modal-content">
        <div class="header-actions">
            <button type="button" class="edit-button" title="수정" style="display:none;" onclick="openUpdateModal()">
                <span class="icon icon-edit"></span>
            </button>
            <button type="button" class="delete-button" title="삭제" style="display:none;" onclick="deleteEvent()">
                <span class="icon icon-delete"></span>
            </button>
            <button type="button" class="modal-close-button" onclick="closeDetailModal()">
                <span class="icon icon-close"></span>
            </button>
        </div>

        <div class="title-section">
            <div class="color-dot" th:style="'background-color:' + ${event?.color}"></div>
            <div class="text-content">
                <div class="main-title" id="detailTitle" th:text="${event?.title}">제목 없음</div>
                <div class="sub-text">
                        <span
                                th:if="${event?.startDatetime != null and event?.endDatetime != null and #temporals.format(event.startDatetime, 'yyyyMMdd') == #temporals.format(event.endDatetime, 'yyyyMMdd') and #temporals.format(event.startDatetime, 'HHmm') == '0000' and #temporals.format(event.endDatetime, 'HHmm') == '2359'}">
                            <span th:text="${#temporals.format(event.startDatetime, 'M월 d일 (E)')} + ' 종일'"></span>
                        </span>
                    <span
                            th:unless="${event?.startDatetime == null or event?.endDatetime == null or (#temporals.format(event.startDatetime, 'yyyyMMdd') == #temporals.format(event.endDatetime, 'yyyyMMdd') and #temporals.format(event.startDatetime, 'HHmm') == '0000' and #temporals.format(event.endDatetime, 'HHmm') == '2359')}">
                            <span
                                    th:text="${event?.startDatetime != null ? #temporals.format(event.startDatetime, 'M월 d일 (E) a h:mm') : '시작일 없음'}"></span>
                            <span> - </span>
                            <span
                                    th:text="${event?.endDatetime != null ? #temporals.format(event.endDatetime, 'M월 d일 (E) a h:mm') : '종료일 없음'}"></span>
                        </span>
                </div>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-user-detail"></span>
            <div class="value-wrapper">
                <label>작성자</label>
                <div class="value" id="detailAuthor"></div>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-user-detail"></span>
            <div class="value-wrapper">
                <label>참가자</label>
                <div class="value" id="detailWorkspaceMembers"></div>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-location-detail"></span>
            <div class="value-wrapper">
                <label>위치</label>
                <div class="value" id="detailLocation"></div>
            </div>
        </div>

        <div id="detail-map" style="width:100%; height:200px; margin-top:10px; display:none;"></div>

        <div class="info-item description">
            <div class="value-wrapper">
                <span class="icon icon-description-detail"><label>설명</label></span>
                <div class="value" id="detailDescriptionDisplay"></div>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-bell-detail"></span>
            <div class="value-wrapper">
                <label>알림</label>
                <div class="value" id="detailNotification"></div>
            </div>
        </div>

        <div class="info-item">
            <div class="value-wrapper">
                <span class="icon icon-attachment-detail"><label>첨부파일</label></span>
                <ul id="detailFiles" class="attachments-list"></ul>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-priority"></span>
            <div class="value-wrapper">
                <label>중요도</label>
                <div class="value" id="detailPriority"></div>
            </div>
        </div>

        <div class="info-item">
            <span class="icon icon-user-detail"></span>
            <div class="value-wrapper">
                <label>공유 여부</label>
                <div class="value" id="detailShared"></div>
            </div>
        </div>


        <div class="modal-footer">
            <button type="button" onclick="closeDetailModal()">닫기</button>
        </div>
    </div>
</div>

<div id="updateEventModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h3>일정 수정</h3>
            <button type="button" class="modal-close-button" onclick="closeUpdateModal()">
                <span class="icon icon-close"></span>
            </button>
        </div>
        <form id="updateEventForm">
            <input type="hidden" id="update-eventCd" name="eventCd" />

            <div class="form-group">
                <label for="update-title" class="icon-description">제목</label>
                <div class="flex-container">
                    <input type="text" id="update-title" name="title" placeholder="제목" required
                           oninvalid="this.setCustomValidity('제목은 필수 입력 사항입니다.')"
                           oninput="this.setCustomValidity('')">
                    <input type="color" id="update-color" name="color" value="#0066CC">
                </div>
            </div>

            <div class="form-group">
                <label class="icon-clock">시작 일시</label>
                <input type="datetime-local" id="update-startDatetime" name="startDatetime" required>
            </div>

            <div class="form-group">
                <label class="icon-clock">종료 일시</label>
                <input type="datetime-local" id="update-endDatetime" name="endDatetime" required>
            </div>

            <div class="form-group">
                <label class="icon-user-detail">참가자 선택</label>
                <div class="checkbox-container" id="update-workspaceMembers"></div>
            </div>

            <div class="form-group">
                <label for="update-description" class="icon-description">설명</label>
                <textarea id="update-description" name="description" rows="4"></textarea>
            </div>

            <div class="form-group">
                <label class="icon-attach">기존 파일</label>
                <ul id="updateFiles" class="current-files-list"></ul>
                <label class="icon-attach file-attach-label">새 파일 첨부</label>
                <div id="update-new-files-container">
                </div>
            </div>

            <div class="form-group">
                <label for="update-notification" class="icon-bell">알림</label>
                <select id="update-notification" name="notification">
                    <option value="1440">전날 오전 9시</option>
                    <option value="540">당일 오전 9시</option>
                    <option value="0">알림 없음</option>
                </select>
            </div>

            <div class="form-group">
                <label for="update-location" class="icon-location">위치</label>
                <div class="search-wrapper">
                    <input type="text" id="update-location" name="location" placeholder="장소명으로 검색하세요">
                    <button type="button" id="update-searchBtn">검색</button>
                </div>
                <div id="update-map" style="width:100%;height:200px;margin-top:10px;"></div>
                <ul id="update-placesList"></ul>

                <input type="hidden" id="update-placeName" name="placeName">
                <input type="hidden" id="update-placeAddress" name="placeAddress">
                <input type="hidden" id="update-placeId" name="placeId">
                <input type="hidden" id="update-placeLat" name="placeLat">
                <input type="hidden" id="update-placeLng" name="placeLng">
            </div>

            <div class="form-group">
                <label for="update-priority" class="icon-priority">우선순위</label>
                <select id="update-priority" name="priority">
                    <option value="LOW">낮음</option>
                    <option value="NORMAL">보통</option>
                    <option value="HIGH">높음</option>
                </select>
            </div>

            <div class="form-group">
                <label for="update-progressStatus">진행 상태</label>
                <select id="update-progressStatus" name="progressStatus">
                    <option value="TODO">예정</option>
                    <option value="IN_PROGRESS">진행중</option>
                    <option value="DONE">완료</option>
                </select>
            </div>

            <div class="form-group">
                <label for="update-isShared">공유 여부</label>
                <select id="update-isShared" name="isShared">
                    <option value="0">비공유</option>
                    <option value="1">공유</option>
                </select>
            </div>

            <div class="modal-footer">
                <button type="button" onclick="submitUpdateEvent()">수정하기</button>
                <button type="button" class="cancel-button" onclick="closeUpdateModal()">취소</button>
            </div>
        </form>
    </div>
</div>
<script th:inline="javascript">
    /*<![CDATA[*/
    const currentUser = /*[[${currentUser}]]*/ '';
    const workspaceCd = /*[[${workspaceCd}]]*/ '';
    let map;
    let marker;
    let detailMap;
    let detailMarker;
    let infowindow;
    let ps;

    console.log("currentUser: " + currentUser.userId);
    console.log("workspaceCd: " + workspaceCd);
    // 현재 로그인 사용자 ID는 백엔드에서 주입되어야 합니다. (더미값)
    /*
    fetch(`/api/user/profile`)
        .then(res => {
            if (!res.ok) throw new Error("유저 정보 조회 실패");
            return res.json();
        })
        .then((data)=>{
            //
            const currentUserId = data.userId;
        })
        .catch(err => {
            console.error(err);
        });*/


    const currentUserId = currentUser.userId;
    const currentUserName = currentUser.userName;
    console.log("currentUserName: " + currentUserName);

    // 새 파일 추가 시 임시로 담아둘 배열 (전역으로 선언)
    let newAddedFiles = [];

    // 파일명 최대 길이 정의 (예시: 100자)
    const MAX_FILENAME_LENGTH = 100;

    document.addEventListener('DOMContentLoaded', function () {
        const calendarEl = document.getElementById('calendar');
        const calendar = new FullCalendar.Calendar(calendarEl, {
            initialView: 'dayGridMonth',
            locale: 'ko',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,timeGridWeek,timeGridDay'
            },
            height: 'auto', // 캘린더 높이 자동 조절
            initialDate: new Date(),
            // 날짜 클릭시 : 일정 추가하는 함수 (createEventModal 띄움)
            dateClick: async function (info) {
                closeDetailModal(); // 혹시 열려있는 상세 모달 닫기
                closeUpdateModal(); // 혹시 열려있는 수정 모달 닫기

                document.getElementById('eventForm').reset(); // 폼 초기화
                // 클릭된 날짜로 시작/종료 일시 기본값 설정
                document.getElementById('startDatetime').value = info.dateStr + 'T09:00';
                document.getElementById('endDatetime').value = info.dateStr + 'T18:00';
                selectedFiles = [];
                document.getElementById('insertedFiles').innerHTML = ''; // 파일 목록 초기화
                document.getElementById('workspaceMembers').innerHTML = '';

                initMap(
                    'map', 'location', 'searchBtn', 'placesList',
                    { name: 'placeName', address: 'placeAddress', id: 'placeId', lat: 'placeLat', lng: 'placeLng' }
                );

                document.getElementById('createEventModal').style.display = 'flex'; // 모달 표시

                setTimeout(function() {
                    map.relayout();
                }, 0);

                fetch(`/api/getMembers?workspaceCd=${workspaceCd}`)
                    .then(res => {
                        if (!res.ok) throw new Error("멤버정보 조회 실패");
                        return res.json();
                    })
                    .then(data => {
                        const membersData = data;
                        const container = document.getElementById('workspaceMembers');

                        for (let i = 0; i < membersData.length; i++) {
                            const member = membersData[i];

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';

                            checkbox.name = 'attendenceIds';

                            const uniqueId = 'userId' + member.userId;
                            checkbox.id = uniqueId;
                            checkbox.value = member.userId;

                            const label = document.createElement('label');
                            label.htmlFor = uniqueId; // id랑 연결
                            label.textContent = member.userNickname;

                            // 현재 로그인한 사용자라면 체크 + 숨기기
                            if (member.userId === currentUserId) {
                                checkbox.checked = true;
                                checkbox.style.display = 'none';
                                label.style.display = 'none';
                            }

                            container.appendChild(checkbox);
                            container.appendChild(label);
                            container.appendChild(document.createElement('br'));
                        }

                    });
            },
            // 개인일정 리스트 풀캘린더에 뿌려주는 부분
            events: function (fetchInfo, successCallback, failureCallback) {
                // userId는 currentUserId를 사용하거나, 백엔드에서 인증 정보로 자동 처리
                fetch(`/api/calendar/personal?userId=${currentUserId}&workspaceCd=${workspaceCd}`)
                    .then(response => {
                        if (!response.ok) throw new Error("불러오기 실패!");
                        return response.json();
                    })
                    .then(data => {
                        const events = data.map(item => ({
                            id: item.eventCd,
                            title: item.title,
                            start: item.startDatetime,
                            end: item.endDatetime,
                            color: item.color
                        }));
                        successCallback(events);
                    })
                    .catch(err => {
                        console.error(err);
                        failureCallback(err);
                    });
            },
            // 일정 클릭 이벤트 : 일정 상세 모달창 띄움
            eventClick: function (info) {
                closeCreateEventModal(); // 혹시 열려있는 생성 모달 닫기
                closeUpdateModal(); // 혹시 열려있는 수정 모달 닫기

                const eventCd = info.event.id;
                fetch(`/api/calendar/personal/events/${eventCd}`)
                    .then(res => {
                        console.log("응답 상태코드:", res.status);
                        if (!res.ok) throw new Error("상세정보 조회 실패");
                        return res.json();
                    })
                    .then(data => {
                        // [추가] 수정 모달을 위해 현재 이벤트 데이터 저장
                        window.selectedEventData = data;

                        const event = data.event;
                        const place = data.place;

                        console.log("event", event);
                        console.log("currentUserId", currentUserId);

                        document.getElementById('detailTitle').innerText = event.title || '제목 없음';
                        document.getElementById('detailAuthor').innerText = event.userName || event.userId || '알 수 없음';
                        document.getElementById('detailDescriptionDisplay').innerText = event.description || '설명 없음';
                        document.getElementById('detailPriority').innerText = event.priority;
                        document.getElementById('detailShared').innerText = event.isShared === '1' ? '예' : '아니오';

                        const notifyTimeMinutes = event.notifyTime;
                        let notificationText = '알림 없음';
                        if (notifyTimeMinutes > 0) {
                            if (notifyTimeMinutes === 1440) notificationText = '전날 9시';
                            else if (notifyTimeMinutes === 540) notificationText = '당일 9시';
                        }
                        document.getElementById('detailNotification').innerText = notificationText;

                        const membersContainer = document.getElementById('detailWorkspaceMembers');
                        if (data.attendences && data.attendences.length > 0) {
                            membersContainer.innerText = data.attendences.map(m => m.userNickName || m.userId).join(", ");
                        } else {
                            membersContainer.innerText = '참가자 없음';
                        }

                        // --- 날짜 및 시간 포맷팅 ---
                        const startDateTime = event.startDatetime ? new Date(event.startDatetime) : null;
                        const endDateTime = event.endDatetime ? new Date(event.endDatetime) : null;
                        let dateTimeDisplay = '';
                        if (startDateTime && endDateTime) {
                            const startDateFormatted = formatDate(startDateTime, 'M월 d일 (E)');
                            if (startDateTime.getHours() === 0 && endDateTime.getHours() === 23) { // 종일 이벤트로 간주
                                dateTimeDisplay = `${startDateFormatted} 종일`;
                            } else {
                                dateTimeDisplay = `${formatDate(startDateTime, 'M월 d일 (E) a h:mm')} - ${formatDate(endDateTime, 'M월 d일 (E) a h:mm')}`;
                            }
                        }
                        document.querySelector('#eventDetailModal .sub-text').innerText = dateTimeDisplay;
                        document.querySelector('#eventDetailModal .color-dot').style.backgroundColor = event.color || '#007bff';

                        // --- 지도 및 위치 정보 처리 ---
                        const detailMapContainer = document.getElementById('detail-map');
                        const detailLocationText = document.getElementById('detailLocation');

                        if (place && place.lat && place.lng) {
                            detailLocationText.innerText = place.address || '주소 정보 없음';
                            detailMapContainer.style.display = 'block';

                            // 지도가 생성될 위치 (마커의 중심 위치)
                            const mapCenter = new kakao.maps.LatLng(place.lat, place.lng);

                            const mapOption = {
                                center: mapCenter, // 지도의 중심 설정
                                level: 3
                            };
                            // 지도 인스턴스 생성
                            detailMap = new kakao.maps.Map(detailMapContainer, mapOption);
                            // 마커 인스턴스 생성 및 지도에 추가
                            detailMarker = new kakao.maps.Marker({
                                position: mapCenter // 마커 위치도 지도의 중심과 동일하게 설정
                            });
                            detailMarker.setMap(detailMap);

                            // [핵심 수정]: 지도를 표시하기 전에 모달을 보이게 한 후, 약간의 지연을 주고 relayout 호출
                            document.getElementById('eventDetailModal').style.display = 'flex';
                            setTimeout(() => {
                                detailMap.relayout(); // 지도 크기 및 중심 재설정
                                detailMap.setCenter(mapCenter); // 확실하게 중심 재설정 (만약 relayout만으로 안될 경우 대비)
                            }, 50); // 0ms 대신 50ms 정도의 작은 지연을 줍니다.

                        } else {
                            detailLocationText.innerText = '위치 정보 없음';
                            detailMapContainer.style.display = 'none';
                            // [추가] 지도가 표시되지 않을 경우 모달만 보이기
                            document.getElementById('eventDetailModal').style.display = 'flex';
                        }

                        // --- 파일 목록 및 버튼 표시 ---
                        const detailFilesUl = document.getElementById('detailFiles');
                        detailFilesUl.innerHTML = '';
                        if (data.fileList && data.fileList.length > 0) {
                            data.fileList.forEach(file => {
                                const li = document.createElement('li');
                                li.innerHTML = `<a href="/api/calendar/personal/events/${event.eventCd}/files?fileId=${file.fileId}" target="_blank"><span class="file-name-display">${file.fileNm}</span></a>`;
                                detailFilesUl.appendChild(li);
                            });
                        } else {
                            detailFilesUl.innerHTML = '<li>첨부파일 없음</li>';
                        }

                        const detailButtonsContainer = document.querySelector('#eventDetailModal .header-actions');
                        const editBtn = detailButtonsContainer.querySelector('.edit-button');
                        const deleteBtn = detailButtonsContainer.querySelector('.delete-button');

                        if (event.userId === currentUserId) {
                            if(editBtn) editBtn.style.display = 'inline-block';
                            if(deleteBtn) deleteBtn.style.display = 'inline-block';
                        } else {
                            if(editBtn) editBtn.style.display = 'none';
                            if(deleteBtn) deleteBtn.style.display = 'none';
                        }

                        // [이전 위치의 모달 표시 및 relayout 로직은 위로 이동됨]
                        // document.getElementById('eventDetailModal').style.display = 'flex';
                        // if (detailMap) {
                        //     setTimeout(() => detailMap.relayout(), 0);
                        // }
                    })
                    .catch(err => {
                        console.error(err);
                        alert("일정 정보를 조회하는데 실패했습니다.");
                    });
            }
        });

        calendar.render();

        // 이전/다음 월 이동 버튼 연결
        document.getElementById('prevMonthBtn').addEventListener('click', function () {
            calendar.prev();
            updateMonthText(calendar);
        });
        document.getElementById('nextMonthBtn').addEventListener('click', function () {
            calendar.next();
            updateMonthText(calendar);
        });
        // 초기 월 텍스트 업데이트
        updateMonthText(calendar);
        function updateMonthText(cal) {
            const currentDate = cal.getDate();
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth() + 1;
            document.getElementById('currentMonthText').innerText = `${year}년 ${month}월`;
        }

        // FullCalendar headerToolbar 버튼을 숨기고 커스텀 버튼 사용
        calendar.setOption('headerToolbar', {
            left: '', // 기본 prev, next, today 버튼 숨김
            center: '', // 기본 타이틀 숨김
            right: '' // 기본 view 버튼 숨김
        });

        // 엔터키로 게시물 작성 / 수정 비 활성화
        function preventSubmitOnEnter(formId) {
            const form = document.getElementById(formId);
            if (form) {
                form.querySelectorAll('input[type="text"], input[type="datetime-local"]').forEach(input => {
                    input.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                        }
                    });
                });
            }
        }
        preventSubmitOnEnter('eventForm');          // '일정 추가' 폼에 적용
        preventSubmitOnEnter('updateEventForm');    // '일정 수정' 폼에 적용
    });

    // Date 객체를 원하는 형식의 문자열로 포맷하는 헬퍼 함수
    function formatDate(date, format) {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1);
        const day = date.getDate();
        const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
        let hours24 = date.getHours();
        let hours12 = hours24 % 12;
        hours12 = hours12 ? hours12 : 12;
        const minutes = date.getMinutes();
        const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;
        const ampm = hours24 >= 12 ? '오후' : '오전';

        return format
            .replace('yyyy', year)
            .replace('M', month)
            .replace('d', day)
            .replace('E', dayOfWeek)
            .replace('HH', hours24 < 10 ? '0' + hours24 : hours24)
            .replace('H', hours24)
            .replace('hh', hours12 < 10 ? '0' + hours12 : hours12)
            .replace('h', hours12)
            .replace('m', formattedMinutes)
            .replace('a', ampm);
    }


    // ====== 일정 추가 모달 함수 (기존 calendar.html 스크립트에서 가져옴) ======
    function closeCreateEventModal() {
        document.getElementById('createEventModal').style.display = 'none';
    }

    function saveEvent() {
        const form = document.getElementById("eventForm");

        // [추가] 파일명 길이 검증
        for (const file of selectedFiles) {
            if (file.name.length > MAX_FILENAME_LENGTH) {
                alert(`첨부하신 파일 '${file.name}'의 이름이 너무 길어 업로드가 불가능합니다.`);
                return; // 업로드 중단
            }
        }

        const formData = new FormData();
        // userId랑 workspaceCd는 임시로 지정해놨어요
        const requestBody = {
            userId: currentUserId,
            workspaceCd: workspaceCd,
            title: form.title.value,
            description: form.description.value,
            startDatetime: form.startDatetime.value,
            endDatetime: form.endDatetime.value,
            color: form.color.value,
            isShared: form.isShared ? form.isShared.value : '0',
            progressStatus: "TODO",
            priority: form.priority.value,
            notifyTime: parseInt(form.notification.value),
            // 장소 정보
            placeName: document.getElementById('placeName').value,
            address: document.getElementById('placeAddress').value,
            placeId: document.getElementById('placeId').value,
            lat: parseFloat(document.getElementById('placeLat').value),
            lng: parseFloat(document.getElementById('placeLng').value)
        };
        // 체크된 참가자 ID들을 하나의 배열로 만듭니다.
        const checkedCheckboxes = document.querySelectorAll('#workspaceMembers input[name="attendenceIds"]:checked');
        const attendenceIds = Array.from(checkedCheckboxes).map(cb => cb.value);

        // 각 데이터를 JSON 형식으로 변환하여 FormData에 추가합니다.
        formData.append("request", new Blob([JSON.stringify(requestBody)], { type: "application/json" }));

        // 참가자 ID 배열도 JSON 형식으로 추가합니다.
        if (attendenceIds) {
            formData.append("attendenceIds", new Blob([JSON.stringify(attendenceIds)], { type: "application/json" }));
        }
        attendenceIds.forEach(cb => {
            formData.append("attendenceIds", cb.value);
        });

        selectedFiles.forEach(file => {
            formData.append("files", file);
        });

        fetch('/api/calendar/personal', {
            method: 'POST',
            body: formData
        })
            .then(res => {
                if (!res.ok) throw new Error('등록 실패');
                return res.text();
            })
            .then(data => {
                alert("일정 등록 성공!");
                location.reload();
            })
            .catch(err => {
                console.error(err);
                alert("서버 오류 발생");
            });

        closeCreateEventModal();
    }

    /* "종일" 체크박스 로직 (createEventModal 내) */
    const createAllDayCheckbox = document.getElementById('allDay');
    const createStartDatetimeInput = document.getElementById('startDatetime');
    const createEndDatetimeInput = document.getElementById('endDatetime');

    createAllDayCheckbox.addEventListener('change', function () {
        if (this.checked) {
            const startDate = new Date(createStartDatetimeInput.value);
            startDate.setHours(0, 0, 0, 0);

            const endDate = new Date(startDate);
            endDate.setHours(23, 59, 59, 999);

            createStartDatetimeInput.value = formatDateToLocalISO(startDate);
            createEndDatetimeInput.value = formatDateToLocalISO(endDate);
        }
    });

    function formatDateToLocalISO(date) {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
    }


    let selectedFiles = [];

    document.getElementById('fileUpload').addEventListener('change', function() {
        const insertedFilesUl = document.getElementById('insertedFiles');

        // 새로 선택한 파일들을 배열에 추가
        for (let i = 0; i < this.files.length; i++) {
            // [추가] 생성 모달에서도 파일명 길이 검증
            if (this.files[i].name.length > MAX_FILENAME_LENGTH) {
                alert(`첨부하신 파일 '${this.files[i].name}'의 이름이 너무 길어 업로드가 불가능합니다.`);
                this.value = ''; // 유효하지 않은 파일은 선택 해제
                return; // 처리 중단
            }
            selectedFiles.push(this.files[i]);
        }
        updateFileListUI(insertedFilesUl, selectedFiles);
        this.value = '';
    });

    function updateFileListUI(targetUlElement, fileArray) {
        targetUlElement.innerHTML = '';

        if (fileArray.length === 0) { // [추가] 파일이 없을 경우 "첨부파일 없음" 표시
            const li = document.createElement('li');
            li.textContent = '첨부파일 없음';
            targetUlElement.appendChild(li);
            return;
        }

        fileArray.forEach((file, index) => {
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.justifyContent = 'space-between';
            li.style.alignItems = 'center';

            const span = document.createElement('span');
            span.className = 'file-name-display';
            span.textContent = file.name;

            const removeButton = document.createElement('button');
            removeButton.textContent = '❌';
            removeButton.type = 'button';
            removeButton.className = 'file-delete-button';
            removeButton.style.background = 'transparent';
            removeButton.style.border = 'none';
            removeButton.style.color = '#ff6b6b';
            removeButton.style.cursor = 'pointer';

            removeButton.addEventListener('click', () => {
                fileArray.splice(index, 1);
                updateFileListUI(targetUlElement, fileArray);
            });

            li.appendChild(span);
            li.appendChild(removeButton);
            targetUlElement.appendChild(li);
        });
    }


    // ====== 일정 상세 모달 함수 (기존 calendar.html 스크립트에서 가져옴) ======
    function closeDetailModal() {
        document.getElementById('eventDetailModal').style.display = 'none';
    }

    // ====== 파일 다운로드 함수 (기존 calendar.html 스크립트에서 가져옴) ======
    function downloadFromS3(fileUrl, fileName) {
        fetch(fileUrl)
            .then(response => {
                if (!response.ok) throw new Error("다운로드 실패");
                return response.blob();
            })
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.error(err);
                alert("파일 다운로드 중 오류가 발생했습니다.");
            });
    }

    // ====== 일정 수정 모달 함수 (기존 calendar.html 스크립트에서 가져옴) ======
    let deletedFileIds = []; // 전역 변수로 관리

    function openUpdateModal() {
        closeCreateEventModal();
        closeDetailModal();

        const data = window.selectedEventData;
        if (!data) {
            alert("수정할 이벤트 데이터가 없습니다.");
            return;
        }

        const eventData = data.event;
        const placeData = data.place;

        // 수정 폼에 기존 값 불러오기
        document.getElementById('update-eventCd').value = eventData.eventCd;
        document.getElementById('update-title').value = eventData.title || '';
        document.getElementById('update-description').value = eventData.description || '';
        document.getElementById('update-startDatetime').value = eventData.startDatetime ? formatDateToLocalISO(new Date(eventData.startDatetime)) : '';
        document.getElementById('update-endDatetime').value = eventData.endDatetime ? formatDateToLocalISO(new Date(eventData.endDatetime)) : '';
        document.getElementById('update-color').value = eventData.color || '#0066CC';
        document.getElementById('update-priority').value = eventData.priority || 'NORMAL';
        document.getElementById('update-progressStatus').value = eventData.progressStatus || 'TODO';
        document.getElementById('update-isShared').value = eventData.isShared === "1" ? '1' : '0'; // '1' 또는 '0'으로 설정
        document.getElementById('update-location').value = data.location || ''; // 위치 필드 추가

        // ▼▼▼ 지도 초기화 로직 추가 ▼▼▼
        initMap(
            'update-map', 'update-location', 'update-searchBtn', 'update-placesList',
            { name: 'update-placeName', address: 'update-placeAddress', id: 'update-placeId', lat: 'update-placeLat', lng: 'update-placeLng' }
        );

        // 기존 장소 정보가 있으면 검색창과 숨겨진 필드를 채워주는 로직
        if (placeData && placeData.lat && placeData.lng) {
            // 1. 검색창 및 숨겨진 필드 값 설정
            document.getElementById('update-location').value = placeData.placeName || '';
            document.getElementById('update-placeName').value = placeData.placeName || '';
            document.getElementById('update-placeAddress').value = placeData.address || '';
            document.getElementById('update-placeId').value = placeData.placeId || '';
            document.getElementById('update-placeLat').value = placeData.lat;
            document.getElementById('update-placeLng').value = placeData.lng;

            // 2. 해당 위치로 지도 이동 및 마커 표시
            const existingPosition = new kakao.maps.LatLng(placeData.lat, placeData.lng);
            map.setCenter(existingPosition);
            marker.setPosition(existingPosition);
        }


        // 알림 시간 설정 (notification 매핑)
        let notificationSelect = document.getElementById('update-notification');
        if (eventData.notifyTime !== undefined && eventData.notifyTime !== null) {
            notificationSelect.value = eventData.notifyTime;
        } else {
            notificationSelect.value = '0'; // 기본값 설정
        }

        // 참가자 체크박스 채우기
        const membersContainer = document.getElementById('update-workspaceMembers');
        membersContainer.innerHTML = '';

        fetch(`/api/getMembers?workspaceCd=${workspaceCd}`)
            .then(res => {
                if (!res.ok) throw new Error("멤버정보 조회 실패");
                return res.json();
            })
            .then(membersData => {
                // 이미 참가중인 사람들
                const attendenceIds = (data.attendences || []).map(m => m.userId);

                membersData.forEach(member => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = 'attendenceIds';
                    checkbox.value = member.userId;
                    checkbox.id = 'update-' + member.userId;

                    // 이미 체크된 사람 표시
                    if (attendenceIds.includes(member.userId)) {
                        checkbox.checked = true;
                    }

                    // 본인은 숨김
                    if (member.userId === currentUserId) {
                        checkbox.checked = true;
                        checkbox.style.display = 'none';
                    }

                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = member.userNickname;

                    if (member.userId === currentUserId) {
                        label.style.display = 'none';
                    }

                    membersContainer.appendChild(checkbox);
                    membersContainer.appendChild(label);
                    membersContainer.appendChild(document.createElement('br'));
                });
            });


        // 기존 파일 목록 불러오기 및 삭제 버튼 초기화
        deletedFileIds = [];
        newAddedFiles = []; // 이전의 '새로 추가된 파일' 개념 (현재는 displayUpdateFiles에서 사용)
        newUpdateFiles = []; // 동적 파일 입력 필드를 위한 새로운 배열 초기화

        // 새 파일 첨부 컨테이너 초기화 및 첫 번째 파일 입력 필드 추가
        const newFilesContainer = document.getElementById('update-new-files-container');
        newFilesContainer.innerHTML = ''; // 컨테이너 비우기
        addUpdateFileInput(); // 새 파일 입력을 위한 첫 번째 필드 추가

        // 기존에 첨부된 파일 표시
        displayUpdateFiles(data.fileList, newAddedFiles); // newAddedFiles는 현재 비어있음

        document.getElementById('updateEventModal').style.display = 'flex'; // 모달 표시

        setTimeout(function() {
            map.relayout();
        }, 0);
    }

    // 새 파일 추가 input에 대한 이벤트 리스너 (update-fileUpload는 이제 사용하지 않음)
    // document.getElementById('update-fileUpload').addEventListener('change', function() { /* 이 부분은 삭제되거나 사용되지 않아야 함 */ });

    function displayUpdateFiles(existingFiles, addedFiles) {
        const updateFilesUl = document.getElementById('updateFiles');
        updateFilesUl.innerHTML = '';

        // 기존 파일 표시
        if (existingFiles && existingFiles.length > 0) {
            existingFiles.forEach(file => {
                const li = document.createElement('li');
                li.innerHTML = `
                        <span class="file-name-display">${file.fileNm}</span>
                        <button type="button" class="file-delete-button" data-file-id="${file.fileId}" onclick="markFileForDeletion('${file.fileId}', this)">파일 삭제</button>
                    `;
                updateFilesUl.appendChild(li);
            });
        }

        // 새로 추가된 파일 표시 (이전 newAddedFiles 로직과 현재 newUpdateFiles 로직이 혼재되어 있었음)
        // 여기서는 newAddedFiles 대신 newUpdateFiles의 유효한 파일들을 보여주는 것이 더 적절합니다.
        // 하지만 현재 HTML 구조와 JavaScript 로직상 newUpdateFiles는 개별 input 필드에 바인딩되므로,
        // 이곳에서는 기존 파일만 display하고, 새로 추가되는 파일은 addUpdateFileInput/handleUpdateFileChange에서 직접 관리하는 것이 좋습니다.
        // 아래 addedFiles는 사실상 newAddedFiles를 의미하며, 이는 이제 사용되지 않으므로 이 부분을 제거하거나 적절히 수정해야 합니다.

        // 이전 newAddedFiles를 사용한 로직 (삭제 또는 주석 처리)
        /*
        if (addedFiles && addedFiles.length > 0) {
            addedFiles.forEach((file, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="file-name-display">${file.name}</span>
                    <button type="button" class="file-delete-button" onclick="removeNewFile(${index}, this)">추가 취소</button>
                `;
                updateFilesUl.appendChild(li);
            });
        }
        */

        // 파일이 없을 경우 "첨부파일 없음" 표시
        if ((!existingFiles || existingFiles.length === 0) && newUpdateFiles.filter(Boolean).length === 0) { // [수정] newUpdateFiles도 확인
            updateFilesUl.innerHTML = '<li>첨부파일 없음</li>';
        }
    }

    // 이 함수는 더 이상 newAddedFiles를 직접적으로 사용하지 않으므로 변경
    // function removeNewFile(index, buttonElement) {
    //     newAddedFiles.splice(index, 1);
    //     displayUpdateFiles(window.selectedEventData.fileList, newAddedFiles);
    // }


    // 파일 삭제 버튼 눌렀을 때 삭제할 파일 아이디 임시로 저장
    function markFileForDeletion(fileId, buttonElement) {
        if (!deletedFileIds.includes(fileId)) { // 중복 추가 방지
            deletedFileIds.push(fileId);
        }
        buttonElement.closest('li').style.textDecoration = 'line-through';
        buttonElement.disabled = true; // 버튼 비활성화
        buttonElement.innerText = '삭제 예정';
    }

    function closeUpdateModal() {
        document.getElementById('updateEventModal').style.display = 'none';
        deletedFileIds = []; // 모달 닫을 때 삭제 목록 초기화
        newAddedFiles = []; // 이전 방식의 새로 추가될 파일 목록 초기화
        newUpdateFiles = []; // 새로운 방식의 개별 파일 입력 필드 목록 초기화

        // 동적으로 추가된 파일 입력 필드 모두 제거
        const newFilesContainer = document.getElementById('update-new-files-container');
        newFilesContainer.innerHTML = '';
        // addUpdateFileInput(); // 모달 닫을 때 초기 필드 추가는 필요 없음 (openUpdateModal에서 처리)


        document.getElementById('updateEventForm').reset(); // 폼 초기화
        document.getElementById('updateFiles').innerHTML = ''; // 파일 목록 초기화
    }

    // 수정사항 저장용
    function submitUpdateEvent() {
        const form = document.getElementById('updateEventForm');
        const formData = new FormData();
        const eventCd = document.getElementById('update-eventCd').value;

        // 최종 파일명 길이 검증 (선택적)
        for (const file of newUpdateFiles) {
            if (file && file.name.length > MAX_FILENAME_LENGTH) {
                alert(`첨부하신 파일 '${file.name}'의 이름이 너무 길어 업로드가 불가능합니다.`);
                return;
            }
        }

        const requestBody = {
            eventCd: eventCd,
            title: form.title.value,
            description: form.description.value,
            startDatetime: form.startDatetime.value,
            endDatetime: form.endDatetime.value,
            color: form.color.value,
            priority: form.priority.value,
            progressStatus: document.getElementById('update-progressStatus').value,
            isShared: form.isShared ? form.isShared.value : '0',
            userId: currentUserId,
            workspaceCd: workspaceCd,
            notifyTime: parseInt(form.notification.value),
            placeName: document.getElementById('update-placeName').value,
            address: document.getElementById('update-placeAddress').value,
            placeId: document.getElementById('update-placeId').value,
            lat: parseFloat(document.getElementById('update-placeLat').value),
            lng: parseFloat(document.getElementById('update-placeLng').value)
        };

        // 참가자 체크박스 값 추가
        const checkedCheckboxes = document.querySelectorAll('#update-workspaceMembers input[name="attendenceIds"]:checked');
        const attendenceIds = Array.from(checkedCheckboxes).map(cb => cb.value);

        // 1. requestBody (JSON) 추가
        formData.append("request", new Blob([JSON.stringify(requestBody)], { type: "application/json" }));

        // 2. deletedFileIds (JSON) 추가
        formData.append("deletedFileIds", new Blob([JSON.stringify(deletedFileIds)], { type: "application/json" }));

        // 3. attendenceIds (JSON) 추가
        // attendenceIds 배열이 비어있더라도 빈 JSON 배열로 보내도록 합니다.
        formData.append("attendenceIds", new Blob([JSON.stringify(attendenceIds)], { type: "application/json" }));

        // 4. files (MultipartFile) 추가
        // newUpdateFiles 배열에서 유효한 파일만 추출
        // 새 파일 추가 로직
        const validNewFiles = newUpdateFiles.filter(file => file instanceof File && file.size > 0);

        if (validNewFiles.length > 0) { // [수정] validNewFiles가 있을 때만 files 파트를 추가합니다.
            validNewFiles.forEach(file => {
                formData.append("files", file);
            });
        }

        fetch(`/api/calendar/personal/events/${eventCd}`, {
            method: 'PUT',
            body: formData
        })
            .then(res => {
                // 서버 응답이 500이더라도, JSON 응답 본문이 있는지 확인하여 디버깅 정보 얻기
                return res.text().then(text => {
                    if (!res.ok) {
                        console.error("서버 응답 오류 (텍스트):", text);
                        throw new Error("수정 실패: " + text); // 서버에서 보낸 에러 메시지를 포함
                    }
                    return text;
                });
            })
            .then(data => {
                alert("일정이 수정되었습니다!");
                closeUpdateModal();
                location.reload();
            })
            .catch(err => {
                console.error(err);
                alert("수정에 실패했습니다. 콘솔을 확인해주세요."); // 사용자에게 더 유용한 메시지
            });
    }

    // ====== 일정 삭제 함수 (기존 calendar.html 스크립트에서 가져옴) ======
    function deleteEvent() {
        const confirmDelete = confirm("정말로 이 일정을 삭제하시겠습니까?");
        if (confirmDelete) {
            const eventCd = window.selectedEventData?.event?.eventCd;
            if (!eventCd) {
                alert("삭제할 이벤트 코드가 없습니다.");
                return;
            }

            fetch(`/api/calendar/personal/events/${eventCd}`, {
                method: 'DELETE'
            })
                .then(res => {
                    if (!res.ok) throw new Error("삭제 실패");
                    return res.text();
                })
                .then(data => {
                    alert("일정이 삭제되었습니다!");
                    closeDetailModal();
                    location.reload(); // 캘린더 새로고침
                })
                .catch(err => {
                    console.error(err);
                    alert("삭제 중 오류가 발생했습니다.");
                });
        } else {
            console.log("삭제 취소됨");
        }
    }

    // 지도와 장소 검색 서비스 초기화 함수
    function initMap(mapContainerId, searchInputId, searchBtnId, listId, hiddenFields) {
        const mapContainer = document.getElementById(mapContainerId);
        const mapOption = {
            center: new kakao.maps.LatLng(37.566826, 126.9786567), // 서울 시청
            level: 3
        };

        // 지도와 마커, 장소 검색 객체 생성
        map = new kakao.maps.Map(mapContainer, mapOption);
        marker = new kakao.maps.Marker({ position: map.getCenter() });
        marker.setMap(map);
        ps = new kakao.maps.services.Places();

        // [추가] 좌표를 주소로 변환하기 위한 지오코더 객체 생성
        const geocoder = new kakao.maps.services.Geocoder();

        // [추가] 지도 클릭 이벤트를 등록합니다
        kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
            // 1. 클릭한 위치에 마커를 표시합니다
            marker.setPosition(mouseEvent.latLng);

            // 2. 클릭한 위치의 좌표로 주소를 검색합니다 (지오코딩)
            geocoder.coord2Address(mouseEvent.latLng.getLng(), mouseEvent.latLng.getLat(), function(result, status) {
                if (status === kakao.maps.services.Status.OK) {
                    const address = result[0]?.road_address?.address_name || result[0]?.address?.address_name;
                    // 3. 검색된 주소로 숨겨진 필드와 검색창의 값을 채웁니다
                    document.getElementById(searchInputId).value = address;
                    document.getElementById(hiddenFields.name).value = address; // 장소명도 주소로 채움
                    document.getElementById(hiddenFields.address).value = address;
                    document.getElementById(hiddenFields.lat).value = mouseEvent.latLng.getLat();
                    document.getElementById(hiddenFields.lng).value = mouseEvent.latLng.getLng();
                    document.getElementById(hiddenFields.id).value = ''; // 장소 ID는 없으므로 비움
                }
            });
        });

        // 검색 버튼 이벤트
        document.getElementById(searchBtnId).addEventListener('click', function () {
            const keyword = document.getElementById(searchInputId).value;
            if (!keyword.replace(/^\s+|\s+$/g, '')) {
                alert('키워드를 입력해주세요!');
                return false;
            }
            ps.keywordSearch(keyword, (data, status, pagination) => {
                placesSearchCB(data, status, pagination, listId, hiddenFields);
            });
        });
    }

    /** 장소 검색 콜백 함수 */
    function placesSearchCB(data, status, pagination, listId, hiddenFields) {
        if (status === kakao.maps.services.Status.OK) {
            displayPlaces(data, listId, hiddenFields);
        } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
            alert('검색 결과가 존재하지 않습니다.');
            return;
        } else if (status === kakao.maps.services.Status.ERROR) {
            alert('검색 결과 중 오류가 발생했습니다.');
            return;
        }
    }

    /** 검색 결과를 목록에 출력하는 함수 */
    function displayPlaces(places, listId, hiddenFields) {
        const listEl = document.getElementById(listId);
        removeAllChildNods(listEl); // 기존 목록 제거

        for (let i = 0; i < places.length; i++) {
            const itemEl = getListItem(i, places[i], hiddenFields);
            listEl.appendChild(itemEl);
        }
    }

    /** 검색 결과 항목(li)을 생성하는 함수 */
    function getListItem(index, place, hiddenFields) {
        const el = document.createElement('li');
        el.className = 'item';

        let itemStr = `<h5>${place.place_name}</h5>` +
            `<div class="info"><span>${place.road_address_name}</span>` +
            `<span class="jibun">지번: ${place.address_name}</span></div>`;

        el.innerHTML = itemStr;

        el.onclick = function() {
            // 지도 이동
            const placePosition = new kakao.maps.LatLng(place.y, place.x);
            map.setCenter(placePosition);
            marker.setPosition(placePosition);

            // 숨겨진 필드에 값 채우기
            document.getElementById(hiddenFields.name).value = place.place_name;
            document.getElementById(hiddenFields.address).value = place.road_address_name || place.address_name;
            document.getElementById(hiddenFields.id).value = place.id;
            document.getElementById(hiddenFields.lat).value = place.y;
            document.getElementById(hiddenFields.lng).value = place.x;

            // 검색창에도 장소명 반영
            const searchInputId = listId.replace('placesList', 'location'); // 'placesList' -> 'location', 'update-placesList' -> 'update-location'
            document.getElementById(searchInputId).value = place.place_name;

            removeAllChildNods(document.getElementById(listId)); // 선택 후 목록 숨기기
        };
        return el;
    }

    /** 목록의 모든 자식 노드를 제거하는 함수 */
    function removeAllChildNods(el) {
        while (el.hasChildNodes()) {
            el.removeChild(el.lastChild);
        }
    }

    /**
     * 파일명을 '10자...확장자' 형식으로 포맷팅하는 함수
     * @param {string} fileName - 원본 파일명
     * @returns {string} 포맷팅된 파일명
     */
    function formatFileName(fileName) {
        const lastDotIndex = fileName.lastIndexOf('.');
        if (lastDotIndex === -1) { // 확장자가 없는 경우
            return fileName.length > 15 ? fileName.substring(0, 15) + '...' : fileName;
        }

        const name = fileName.substring(0, lastDotIndex);
        const extension = fileName.substring(lastDotIndex); // . 포함

        if (name.length > 10) {
            return name.substring(0, 10) + '...' + extension;
        }
        return fileName;
    }

    let newUpdateFiles = []; // 동적 파일 입력 필드에 선택된 파일들을 저장할 배열

    /**
     * 수정 모달에 새 파일 입력 필드를 추가하는 함수
     */
    function addUpdateFileInput() {
        const container = document.getElementById('update-new-files-container');

        const wrapper = document.createElement('div');
        wrapper.className = 'file-input-container'; // 기존 file-input-container 클래스 재사용
        wrapper.dataset.fileIndex = newUpdateFiles.length; // 배열의 인덱스를 저장

        // HTML 구조를 JavaScript에서 직접 생성하여 정확성을 높입니다.
        wrapper.innerHTML = `
        <span class="icon icon-attach"></span>
        <span class="file-select-text">파일 선택</span>
        <input type="file" name="newFiles" onchange="handleUpdateFileChange(event)"> <span class="file-name-display" style="display: none;"></span>
        <button type="button" class="new-file-delete-button" style="display: none;" onclick="removeUpdateFile(this)">❌</button>
    `;
        container.appendChild(wrapper);

        // [핵심 수정]: input[type="file"]의 pointer-events를 동적으로 제어하기 위해 참조를 얻습니다.
        const fileInput = wrapper.querySelector('input[type="file"]');
        const selectTextSpan = wrapper.querySelector('.file-select-text');
        const deleteButton = wrapper.querySelector('.new-file-delete-button');

        // "파일 선택" 텍스트를 클릭하면 실제 input[type="file"]을 클릭하도록 유도
        selectTextSpan.addEventListener('click', function() {
            fileInput.click();
        });

        // input[type="file"]의 pointer-events 초기 설정 (파일이 선택되지 않은 상태)
        fileInput.style.pointerEvents = 'auto'; // 기본적으로 클릭 가능
        fileInput.style.opacity = '0'; // 투명하게 유지하여 UI를 해치지 않음

        // X 버튼에 대한 이벤트 리스너는 HTML 인라인 `onclick` 대신 JS에서 명시적으로 추가
        // (이전 코드에서 이미 인라인 onclick이 있었으므로, 필요시 중복 방지)
        // deleteButton.addEventListener('click', function() { removeUpdateFile(this); });
    }

    /**
     * 수정 모달에서 파일이 선택되었을 때 처리하는 함수
     */
    function handleUpdateFileChange(event) {
        const input = event.target;
        const wrapper = input.closest('.file-input-container');
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        const fileIndex = parseInt(wrapper.dataset.fileIndex, 10);

        // 파일명 길이 검증
        if (file.name.length > MAX_FILENAME_LENGTH) {
            alert(`첨부하신 파일 '${file.name}'의 이름이 너무 길어 업로드가 불가능합니다.`);
            input.value = ''; // 유효하지 않은 파일은 선택 해제
            return; // 처리 중단
        }

        // 파일 배열에 추가 (또는 교체)
        newUpdateFiles[fileIndex] = file;

        // UI 업데이트
        wrapper.querySelector('.file-select-text').style.display = 'none'; // '파일 선택' 텍스트 숨기기

        const fileNameDisplay = wrapper.querySelector('.file-name-display');
        fileNameDisplay.textContent = formatFileName(file.name);
        fileNameDisplay.style.display = 'block';

        const deleteButton = wrapper.querySelector('.new-file-delete-button');
        deleteButton.style.display = 'block';
        wrapper.classList.add('has-file');

        // [핵심 수정]: 파일이 선택되면 input[type="file"]의 클릭 이벤트를 비활성화합니다.
        input.style.pointerEvents = 'none'; // 이제 이 input은 클릭 이벤트를 받지 않습니다.

        // 새로운 파일 입력 필드 추가 (새로운 파일 선택 공간을 제공)
        const hasExistingEmptyInput = Array.from(wrapper.parentNode.children).some(child =>
            child.classList.contains('file-input-container') && !child.classList.contains('has-file')
        );
        if (!hasExistingEmptyInput) {
            addUpdateFileInput();
        }
    }

    /**
     * 수정 모달에서 새로 추가한 파일을 제거하는 함수
     */
    function removeUpdateFile(button) {
        const wrapper = button.closest('.file-input-container');
        const fileIndex = parseInt(wrapper.dataset.fileIndex, 10);

        // 파일 배열에서 해당 파일 제거 (null로 표시)
        newUpdateFiles[fileIndex] = null;

        // DOM에서 해당 입력 필드 제거
        wrapper.remove();

        // 만약 '파일 선택' 상태인 입력 필드가 하나도 없다면 새로 추가
        const container = document.getElementById('update-new-files-container');
        if (!container.querySelector('.file-input-container:not(.has-file)')) {
            addUpdateFileInput();
        }
    }
    /*]]>*/
</script>
</body>

</html>